Горчаков Роман Владимирович. Вариант 2
# Лабораторная работа 2.25. Управление процессами в Python

Процессы в Python позволяют запустить выполнение нескольких задач в параллельном режиме. По сути, при старте процесса запускает еще одна копия интерпретатора Python, в котором выполняется указанная функция. Таким образом, если мы запустим пять процессов, то будет запущено пять отдельных интерпретаторов, в этом случае уже не будет проблем с GIL. Такой способ позволяет параллельно запускать задачи активно использующие CPU. Они будут распределяться между несколькими процессами (ядрами), что значительно увеличит производительность вычислений.

Классом, который отвечает за создание и управление процессами является Process из пакета multiprocessing. Он совместим по сигнатурам методов и конструктора с threading.Thread, это сделано для более простого перехода от многопотокового приложения к многопроцессному. Помимо одноименных с Thread методов, класс Process дополнительно предоставляет ряд своих. Параметры конструктора:
* group - параметр всегда равен None, используется для обратной совместимости с Thread;
* target - Сallable-объект, который будет вызван методом run() при старте процесса;
* name - имя процесса;
* args, kwargs - параметры объекта, переданного через target;
* daemon - флаг, определяющий является ли данный процесс демоном (True) или нет (False). Если значение не задано, то оно будет равно свойству daemon родительского процесса.

Помимо методов и свойств, которые совпадают по назначению с аналогичными для класса Thread, класс Process имеет ряд уникальных:
* pid - возвращает ID процесса. Если процесс ещё не запущен, то вернет None;
* exitcode - код возврата. Если процесс ещё не завершил свою работу, то вернет None;
* authkey - ключ аутентификации процесса. При инициализации multiprocessing, с главным процессом связывается специальная строка, которая генерируется с помощью os.urandom(). Это значение наследуют процессы-потомки, но его можно изменить, задав новое значение, через данное свойство;
* sentinel - числовой идентификатор, который может использоваться для синхронизации;
* close() - освобождает все ресурсы, связанные с процессом. Если процесс еще работает, то вызов метода приведет к выбросу исключения ValueError.

При вывозе метода join() выполнение программы будет остановлено до тех пор пока соответствующий процесс не завершит работу. Параметр timeout отвечает за время ожидания завершения работы процесса, если указанное время прошло, а процесс еще не завершился, то ожидание будет прервано и выполнение программы продолжится дальше. В случае, если метод join() завершился по таймауту или в результате того, что процесс был завершен аварийно (терминирован), то он вернет None.

В классе-наследнике от Process необходимо переопределить метод run() для того, чтобы он (класс) соответствовал протоколу работы с процессами. В отличии от потоков, работу процессов можно принудительно завершить, для этого класс Process предоставляет набор методов:
* terminate() - принудительно завершает работу процесса. В Unix отправляется команда SIGTERM, в Windows используется функция TerminateProcess();
* kill() - метод аналогичный terminate() по функционалу, только вместо SIGTERM в Unix будет отправлена команда SIGKILL.

Процессы демоны по своим свойствам похожи на потоки-демоны, их суть заключается в том, что они завершают свою работу, если завершился родительский процесс. Указание на то, что процесс является демоном должно быть сделано до его запуска (до вызова метода start()). Для демонического процесса запрещено самостоятельно создавать дочерние процессы. Эти процессы не являются демонами (сервисами) в понимании Unix, единственное их свойство – это завершение работы вместе с родительским процессом. Указать на то, что процесс является демоном можно при создании экземпляра класса через аргумент daemon, либо после создания через свойство daemon.
